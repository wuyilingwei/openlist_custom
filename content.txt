<!-- å»¶è¿ŸåŠ è½½ -->
<div id="customize" style="display: none;">
  <div>
    <br />
    <center class="custom-footer">
        <div class="custom-footer-power">
          <a id="power_text">
            Powered By OpenList
          </a>
        </div>
      </div>
    </center>
    <br />
  </div>
</div>

<!-- å»¶è¿ŸåŠ è½½JS -->
<script>
  let interval = setInterval(() => {
    if (document.querySelector(".footer")) {
      document.querySelector("#customize").style.display = "";
      clearInterval(interval);
    }
  }, 200);
</script>

<script>
  (function () {
    const addButtonsInterval = setInterval(() => {
      const toolbarInner = document.querySelector(".left-toolbar-in");
      if (!toolbarInner) return;

      // é€šç”¨åˆ›å»ºå‡½æ•°ï¼šæ”¯æŒè‡ªå®šä¹‰ viewBox
      function createToolbarLink(tips, href, pathD, titleZh, titleEn, viewBox = "0 0 24 24") {
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("viewBox", viewBox);
        svg.setAttribute("height", "1em");
        svg.setAttribute("width", "1em");
        svg.setAttribute("fill", "currentColor");
        svg.setAttribute("color", "currentColor");
        svg.setAttribute("tips", tips);
        svg.setAttribute(
          "class",
          "hope-icon hope-c-XNyZK hope-c-PJLV hope-c-PJLV-idBCZDE-css toolbar-extra"
        );
        svg.style.cursor = "pointer";
        svg.style.position = "relative";

        // åˆ›å»ºè‡ªå®šä¹‰ tooltip å…ƒç´ 
        const lang = localStorage.getItem('lang');
        const tooltipText = (lang === 'zh-CN') ? titleZh : titleEn;
        const tooltip = document.createElement("div");
        tooltip.textContent = tooltipText;
        tooltip.className = "custom-tooltip tooltip-left";
        
        // å°†tooltipæ·»åŠ åˆ°bodyä¸­è€Œä¸æ˜¯svgå†…éƒ¨
        document.body.appendChild(tooltip);

        // è®© SVG æœ¬èº«è¡¨ç°å¾—åƒæŒ‰é’®
        svg.setAttribute("role", "button");
        svg.setAttribute("tabindex", "0");
        svg.setAttribute("aria-label", tooltipText);

        // å›¾æ ‡è·¯å¾„
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute("fill", "currentColor");
        path.setAttribute("d", pathD);
        svg.appendChild(path);

        // è®¡ç®—tooltipä½ç½®çš„å‡½æ•°
        function updateTooltipPosition() {
          const rect = svg.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();
          
          // å®šä½åœ¨å…ƒç´ å·¦ä¾§
          tooltip.style.left = (rect.left - tooltipRect.width - 10) + 'px';
          tooltip.style.top = (rect.top + rect.height / 2 - tooltipRect.height / 2) + 'px';
        }

        // é¼ æ ‡æ‚¬åœäº‹ä»¶
        svg.addEventListener("mouseenter", () => {
          updateTooltipPosition();
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
        });

        svg.addEventListener("mouseleave", () => {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        });

        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è®¡ç®—ä½ç½®
        window.addEventListener("resize", () => {
          if (tooltip.style.visibility === "visible") {
            updateTooltipPosition();
          }
        });

        // ç‚¹å‡»æ‰“å¼€æ–°æ ‡ç­¾
        svg.addEventListener("click", function (e) {
          e.stopPropagation();
          window.open(href, "_blank");
        });

        // é”®ç›˜å›è½¦ä¹Ÿèƒ½è§¦å‘
        svg.addEventListener("keydown", function (e) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            window.open(href, "_blank");
          }
        });

        toolbarInner.appendChild(svg);
      }

      // ç™»å½•æŒ‰é’®ï¼ˆ24Ã—24 å›¾æ ‡ï¼‰
      createToolbarLink(
        "login",
        "/@login",
        "M10 2a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm0 10c-3.314 0-6 2.239-6 5v1h2v-1c0-1.657 1.79-3 4-3h1v-2h-1Zm5 1v3h-3v2h3v3l5-4-5-4Z",
        "ç”¨æˆ·ç™»å½•",
        "User Login",
        "0 0 24 24"
      );

      // ç®¡ç†æŒ‰é’®ï¼ˆiconfont 1024Ã—1024 å›¾æ ‡ï¼‰
      createToolbarLink(
        "manage",
        "/@manage",
        "M224 423.84V231.744l192-0.096 0.096 192.096L224 423.84z m192.096-256.096H223.904A64 64 0 0 0 160 231.68v192.192a64 64 0 0 0 63.904 63.904h192.192A64 64 0 0 0 480 423.84V231.68a64 64 0 0 0-63.904-63.904zM224 807.84v-192.096l192-0.096 0.096 192.096L224 807.84z m192.096-256.096H223.904A64 64 0 0 0 160 615.68v192.192a64 64 0 0 0 63.904 63.904h192.192A64 64 0 0 0 480 807.84V615.68a64 64 0 0 0-63.904-63.904zM704.064 463.616l-135.84-135.84 135.712-135.84 135.904 135.744-135.776 135.936z m181.024-181.024l-135.904-135.904a64 64 0 0 0-90.368 0L522.912 282.56a63.456 63.456 0 0 0-18.656 45.056 63.456 63.456 0 0 0 18.656 45.312l135.904 135.936a63.904 63.904 0 0 0 90.368-0.032l135.904-135.904a63.936 63.936 0 0 0 0-90.368zM608 807.84v-192.096l192-0.096 0.096 192.096-192.096 0.096z m192.096-256.096h-192.192A64 64 0 0 0 544 615.68v192.192a64 64 0 0 0 63.904 63.904h192.192A64 64 0 0 0 864 807.84V615.68a64 64 0 0 0-63.904-63.904z",
        "ç³»ç»Ÿç®¡ç†",
        "System Management",
        "0 0 1024 1024"
      );

      // åˆ é™¤ "æ›´å¤š" æŒ‰é’®
      setTimeout(() => {
        const moreButton = document.querySelector('svg[tips="more"]');
        if (moreButton) {
          moreButton.remove();
        }
      }, 100);

      clearInterval(addButtonsInterval);
    }, 400);
  })();
</script>

<script>
  // æ™ºèƒ½è·¯å¾„é‡å®šå‘åŠŸèƒ½
  (function() {
    // ==================== é…ç½®é¡¹ ====================
    const CONFIG = {
      // è®¿å®¢åŸºç¡€URLï¼ˆæœªç™»å½•ç”¨æˆ·çš„URLå‰ç¼€ï¼‰
      GUEST_BASE_URL: '/public',
      
      // æ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼
      DEBUG: false
    };
    
    // è°ƒè¯•æ—¥å¿—å‡½æ•°
    function debugLog(...args) {
      if (CONFIG.DEBUG) {
        console.log(...args);
      }
    }
    
    // ==================== æ ¸å¿ƒå‡½æ•° ====================
    
    // è·å–localStorageä¸­çš„è®¤è¯token
    function getAuthToken() {
      try {
        const token = localStorage.getItem('token');
        if (token) {
          debugLog(`ğŸ” [è®¤è¯] æ‰¾åˆ°localStorage token: ${token.substring(0, 10)}...`);
          return token;
        }
        debugLog(`ğŸ”“ [è®¤è¯] localStorageä¸­æœªæ‰¾åˆ°tokenï¼Œä½¿ç”¨è®¿å®¢èº«ä»½`);
        return null;
      } catch (error) {
        console.error(`ğŸ’¥ [è®¤è¯é”™è¯¯] è·å–localStorage tokenå¤±è´¥:`, error);
        return null;
      }
    }
    
    // æ„å»ºè¯·æ±‚å¤´ï¼ˆåŒ…å«è®¤è¯ä¿¡æ¯ï¼‰
    function buildRequestHeaders() {
      const headers = { 'Content-Type': 'application/json' };
      const token = getAuthToken();
      
      if (token) {
        headers['Authorization'] = `${token}`;
        debugLog(`ğŸ” [è¯·æ±‚å¤´] å·²æ·»åŠ è®¤è¯å¤´`);
      } else {
        debugLog(`ğŸ”“ [è¯·æ±‚å¤´] æ— è®¤è¯å¤´ï¼ˆè®¿å®¢æ¨¡å¼ï¼‰`);
      }
      
      return headers;
    }
    
    // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨çš„é€šç”¨å‡½æ•°
    async function checkPathExists(path) {
      debugLog(`ğŸ” [checkPathExists] æ£€æŸ¥è·¯å¾„: "${path}"`);
      
      try {
        const requestBody = { path: path, password: "" };
        const headers = buildRequestHeaders();
        
        debugLog(`ğŸ“¤ [APIè¯·æ±‚] POST /api/fs/get`, requestBody);
        debugLog(`ğŸ” [è®¤è¯çŠ¶æ€] ${headers.Authorization ? 'å·²è®¤è¯' : 'è®¿å®¢æ¨¡å¼'}`);
        
        const response = await fetch('/api/fs/get', {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(requestBody)
        });
        
        debugLog(`ğŸ“¥ [HTTPå“åº”] status: ${response.status}, ok: ${response.ok}`);
        
        if (!response.ok) {
          debugLog(`âŒ [HTTPé”™è¯¯] å“åº”çŠ¶æ€å¼‚å¸¸: ${response.status}`);
          return false;
        }
        
        const data = await response.json();
        debugLog(`ğŸ“‹ [APIå“åº”] code: ${data.code}, message: "${data.message || 'N/A'}"`);
        
        const exists = data.code === 200;
        debugLog(`${exists ? 'âœ…' : 'âŒ'} [ç»“æœ] è·¯å¾„ "${path}" ${exists ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'}`);
        
        return exists;
      } catch (error) {
        console.error(`ğŸ’¥ [å¼‚å¸¸] è·¯å¾„æ£€æŸ¥å¤±è´¥: ${path}`, error);
        return false;
      }
    }
    
    // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ä¿®å¤è·¯å¾„
    function generateFixAttempts(originalPath, userBasePath) {
      debugLog(`ğŸ”§ [generateFixAttempts] ç”Ÿæˆä¿®å¤å°è¯•`);
      debugLog(`   åŸå§‹è·¯å¾„: "${originalPath}"`);
      debugLog(`   ç”¨æˆ·åŸºç¡€è·¯å¾„: "${userBasePath}"`);
      
      const attempts = [];
      
      // å°è¯•1ï¼šå»æ‰ç”¨æˆ·åŸºç¡€è·¯å¾„
      if (userBasePath && userBasePath !== '/' && originalPath.startsWith(userBasePath)) {
        const path1 = originalPath.substring(userBasePath.length) || '/';
        attempts.push({
          name: 'å»æ‰ç”¨æˆ·åŸºç¡€è·¯å¾„',
          path: path1,
          description: `ä» "${originalPath}" ç§»é™¤ç”¨æˆ·åŸºç¡€è·¯å¾„ "${userBasePath}"`
        });
      }
      
      // å°è¯•2ï¼šæ·»åŠ è®¿å®¢åŸºç¡€URL
      if (!originalPath.startsWith(CONFIG.GUEST_BASE_URL)) {
        const path2 = CONFIG.GUEST_BASE_URL + originalPath;
        attempts.push({
          name: 'æ·»åŠ è®¿å®¢åŸºç¡€URL',
          path: path2,
          description: `ä¸º "${originalPath}" æ·»åŠ è®¿å®¢å‰ç¼€ "${CONFIG.GUEST_BASE_URL}"`
        });
      }
      
      // å°è¯•3ï¼šè·¯å¾„å»é‡ä¿®å¤
      if (userBasePath && userBasePath !== '/') {
        const baseSegments = userBasePath.split('/').filter(seg => seg);
        const currentSegments = originalPath.split('/').filter(seg => seg);
        
        debugLog(`   [è·¯å¾„åˆ†æ] ç”¨æˆ·åŸºç¡€æ®µ: [${baseSegments.join(', ')}]`);
        debugLog(`   [è·¯å¾„åˆ†æ] å½“å‰è·¯å¾„æ®µ: [${currentSegments.join(', ')}]`);
        
        // å¯»æ‰¾é‡å¤çš„è·¯å¾„æ®µ
        for (let i = 0; i < currentSegments.length - baseSegments.length + 1; i++) {
          const isMatch = baseSegments.every((baseSeg, idx) => 
            currentSegments[i + idx] === baseSeg
          );
          
          if (isMatch) {
            const remainingSegments = currentSegments.slice(i + baseSegments.length);
            if (remainingSegments.length > 0) {
              const path3 = '/' + remainingSegments.join('/');
              if (path3 !== originalPath) {
                attempts.push({
                  name: 'è·¯å¾„å»é‡',
                  path: path3,
                  description: `ä» "${originalPath}" å»é™¤é‡å¤è·¯å¾„æ®µï¼Œä¿ç•™ "${path3}"`
                });
              }
            }
          }
        }
      }
      
      // å°è¯•4ï¼šè®¿å®¢URL + å»é‡ç»„åˆ
      if (userBasePath && userBasePath !== '/') {
        const baseSegments = userBasePath.split('/').filter(seg => seg);
        const currentSegments = originalPath.split('/').filter(seg => seg);
        
        for (let i = 0; i < currentSegments.length - baseSegments.length + 1; i++) {
          const isMatch = baseSegments.every((baseSeg, idx) => 
            currentSegments[i + idx] === baseSeg
          );
          
          if (isMatch) {
            const remainingSegments = currentSegments.slice(i + baseSegments.length);
            if (remainingSegments.length > 0) {
              const deduped = '/' + remainingSegments.join('/');
              const path4 = CONFIG.GUEST_BASE_URL + deduped;
              if (path4 !== originalPath && !deduped.startsWith(CONFIG.GUEST_BASE_URL)) {
                attempts.push({
                  name: 'è®¿å®¢URL+å»é‡',
                  path: path4,
                  description: `å»é‡åæ·»åŠ è®¿å®¢å‰ç¼€: "${deduped}" â†’ "${path4}"`
                });
              }
            }
          }
        }
      }
      
      debugLog(`ğŸ“‹ [ç”Ÿæˆç»“æœ] å…± ${attempts.length} ä¸ªä¿®å¤å°è¯•:`);
      attempts.forEach((attempt, index) => {
        debugLog(`   ${index + 1}. [${attempt.name}] ${attempt.path}`);
      });
      
      return attempts;
    }
    
    // ==================== ä¸»è¦é€»è¾‘ ====================
    
    async function checkAndRedirectPath() {
      debugLog(`ğŸš€ [æ™ºèƒ½é‡å®šå‘] å¼€å§‹æ‰§è¡Œ...`);
      
      try {
        // è·å–ç”¨æˆ·ä¿¡æ¯
        debugLog(`ğŸ‘¤ [ç”¨æˆ·ä¿¡æ¯] è·å–å½“å‰ç”¨æˆ·...`);
        const headers = buildRequestHeaders();
        
        const userResponse = await fetch('/api/me', {
          method: 'GET',
          headers: headers
        });
        debugLog(`ğŸ“¥ [ç”¨æˆ·API] å“åº”: ${userResponse.status}, ok: ${userResponse.ok}`);
        debugLog(`ğŸ” [ç”¨æˆ·API] è®¤è¯çŠ¶æ€: ${headers.Authorization ? 'å·²è®¤è¯' : 'è®¿å®¢æ¨¡å¼'}`);
        
        if (!userResponse.ok) {
          debugLog(`âŒ [ç”¨æˆ·API] è·å–å¤±è´¥ï¼Œé€€å‡º`);
          return;
        }
        
        const userData = await userResponse.json();
        debugLog(`ğŸ“‹ [ç”¨æˆ·æ•°æ®]`, userData);
        
        if (userData.code !== 200 || !userData.data) {
          debugLog(`âŒ [ç”¨æˆ·æ•°æ®] æ— æ•ˆæ•°æ®ï¼Œé€€å‡º`);
          return;
        }
        
        const userBasePath = userData.data.base_path;
        const currentPath = decodeURIComponent(window.location.pathname);
        
        debugLog(`ğŸŒ [è·¯å¾„ä¿¡æ¯] å½“å‰è·¯å¾„: "${currentPath}"`);
        debugLog(`ğŸ“ [è·¯å¾„ä¿¡æ¯] ç”¨æˆ·åŸºç¡€è·¯å¾„: "${userBasePath}"`);
        
        // æ£€æŸ¥å½“å‰è·¯å¾„æ˜¯å¦æœ‰æ•ˆ
        debugLog(`\n=== ğŸ¯ [ä¸»è¦æ£€æŸ¥] éªŒè¯å½“å‰è·¯å¾„ ===`);
        const currentExists = await checkPathExists(currentPath);
        
        if (currentExists) {
          debugLog(`ğŸ‰ [æˆåŠŸ] å½“å‰è·¯å¾„æœ‰æ•ˆï¼Œæ— éœ€é‡å®šå‘ï¼`);
          return;
        }
        
        debugLog(`\n=== ğŸ’¡ [ä¿®å¤æ¨¡å¼] å¼€å§‹æ™ºèƒ½ä¿®å¤ ===`);
        
        // ç”Ÿæˆä¿®å¤å°è¯•
        const attempts = generateFixAttempts(currentPath, userBasePath);
        
        if (attempts.length === 0) {
          debugLog(`âŒ [æ— æ³•ä¿®å¤] æ²¡æœ‰å¯ç”¨çš„ä¿®å¤æ–¹æ¡ˆ`);
          return;
        }
        
        // ä¾æ¬¡å°è¯•æ¯ä¸ªä¿®å¤æ–¹æ¡ˆ
        for (let i = 0; i < attempts.length; i++) {
          const attempt = attempts[i];
          debugLog(`\n--- ğŸ”§ [å°è¯• ${i + 1}/${attempts.length}] ${attempt.name} ---`);
          debugLog(`ğŸ“ [æè¿°] ${attempt.description}`);
          
          if (await checkPathExists(attempt.path)) {
            debugLog(`ğŸ¯ [é‡å®šå‘æˆåŠŸ] ${currentPath} â†’ ${attempt.path}`);
            window.location.replace(attempt.path);
            return;
          } else {
            debugLog(`âŒ [å°è¯•å¤±è´¥] ä¿®å¤åè·¯å¾„ä»ä¸å­˜åœ¨`);
          }
        }
        
        debugLog(`\nğŸ’” [å…¨éƒ¨å¤±è´¥] æ‰€æœ‰ä¿®å¤å°è¯•å‡æ— æ•ˆ`);
        
      } catch (error) {
        console.error(`ğŸ’¥ [ä¸¥é‡é”™è¯¯] é‡å®šå‘åŠŸèƒ½å¼‚å¸¸:`, error);
      }
    }
    
    // ==================== å¯åŠ¨é€»è¾‘ ====================
    
    debugLog(`ğŸ“Œ [åˆå§‹åŒ–] æ™ºèƒ½è·¯å¾„é‡å®šå‘åŠŸèƒ½å·²åŠ è½½`);
    debugLog(`âš™ï¸ [é…ç½®] è®¿å®¢åŸºç¡€URL: "${CONFIG.GUEST_BASE_URL}"`);
    
    // é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œæ£€æŸ¥
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', checkAndRedirectPath);
    } else {
      setTimeout(checkAndRedirectPath, 500);
    }
  })();
</script>